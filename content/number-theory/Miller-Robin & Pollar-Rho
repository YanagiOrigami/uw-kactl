ll mul(ll x,ll y,ll Mod){
	x%=Mod;y%=Mod;
	return (x*y-(ll)(((long double)x*y+0.5)/(long double)Mod)*Mod+Mod)%Mod;
}
ll Pow2(ll x,ll y,ll Mod){
	ll ans=1;x%=Mod;
	for(;y;ans=(y&1?mul(x,ans,Mod):ans),y>>=1,x=mul(x,x,Mod));
	return ans;
}
int Pow(int x,ll y,int Mod){
	int ans=1;x%=Mod;
	for(;y;ans=(y&1?1LL*x*ans%Mod:ans),y>>=1,x=1LL*x*x%Mod);
	return ans;
}
ll f[]={2,3,5,7,11,13,17,19,23,29};
bool Miller_Robin(ll p){
	ll P=p-1,z=0,w,x;
	while(~P&1) P>>=1,z++;
	rep(i,0,10){
		w=Pow2(f[i],P,p);
		if(p<=f[i]) break;
		if(Pow2(f[i],p-1,p)!=1) return false;
		for(int _=z;_--;w=x){
			x=mul(w,w,p);
			if(x==1&&w!=1&&w!=p-1) return false;
		}
	}
	return true;
}//素数测试，很憨，背背流程。
ll Pollard_Rho(ll p,ll c){
	ll i=0,k=2,x,y;x=y=1+rand()%(p-1);
	while(1){
		x=(mul(x,x,p)+c)%p;
		ll d=__gcd((y-x+p)%p,p);
		if(d!=1&&d!=p) return d;
		if(x==y) return p;
		if(++i==k) y=x,k<<=1;
	}
}//重复一个找环的过程。
void fact(ll x){
	if(x==1) return ;
	if(Miller_Robin(x)) return (void)(tmp[++len]=x);
	ll p=x;
	for(int c=233;p==x;c--) p=Pollard_Rho(p,c);
	fact(p),fact(x/p);
}
